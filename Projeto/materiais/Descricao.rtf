{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1046{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang22\par
O Bubble Sort \'e9 um algoritmo de ordena\'e7\'e3o simples, mas ineficiente para listas grandes. Ele funciona comparando elementos adjacentes de uma lista e, se os elementos n\'e3o est\'e3o na ordem correta, troca-os de lugar. Esse processo de compara\'e7\'e3o e troca \'e9 repetido at\'e9 que a lista esteja completamente ordenada. Em outras palavras, o algoritmo percorre a lista v\'e1rias vezes, comparando e trocando os elementos at\'e9 que n\'e3o sejam mais necess\'e1rias trocas. A cada passagem, o maior elemento "borbulha" para o final da lista, o que d\'e1 origem ao nome do algoritmo.\par
\par
Por exemplo, dada a lista [5, 2, 9, 1, 5, 6], o Bubble Sort come\'e7a comparando o primeiro elemento (5) com o segundo (2). Como 5 \'e9 maior que 2, os dois elementos s\'e3o trocados, resultando na lista [2, 5, 9, 1, 5, 6]. O processo de compara\'e7\'e3o e troca continua, agora com 5 e 9, mas como 5 \'e9 menor que 9, nada acontece. O algoritmo segue esse processo para os elementos seguintes e repete essa sequ\'eancia de passos at\'e9 que todos os elementos estejam na ordem crescente desejada.\par
\par
Em termos de complexidade te\'f3rica, o Bubble Sort apresenta uma performance que varia conforme o estado inicial da lista. No melhor caso (quando a lista j\'e1 est\'e1 ordenada), o algoritmo realiza apenas uma passagem pela lista, verificando que nenhum elemento precisa ser trocado. Nesse caso, a complexidade \'e9 O(n), onde n \'e9 o n\'famero de elementos da lista. No pior caso, que ocorre quando a lista est\'e1 em ordem inversa, o algoritmo precisa percorrer toda a lista e realizar trocas em cada compara\'e7\'e3o, resultando em uma complexidade de O(n\'b2). Esse comportamento \'e9 t\'edpico do Bubble Sort, e sua inefici\'eancia se torna evidente em listas grandes, o que limita seu uso em situa\'e7\'f5es que exigem desempenho elevado.\line\line O Insertion Sort \'e9 um algoritmo de ordena\'e7\'e3o que funciona de maneira semelhante ao processo de ordenar cartas em m\'e3os. O algoritmo come\'e7a com o segundo elemento da lista e o compara com os elementos anteriores. Se o elemento comparado for menor que o anterior, ele \'e9 "inserido" na posi\'e7\'e3o correta, movendo os elementos maiores para a direita para abrir espa\'e7o. Esse processo \'e9 repetido para cada elemento subsequente, at\'e9 que a lista esteja completamente ordenada. A ideia central \'e9 que, a cada itera\'e7\'e3o, a parte da lista que j\'e1 foi analisada estar\'e1 sempre ordenada.\par
\par
Por exemplo, dada a lista [5, 2, 9, 1, 5, 6], o algoritmo come\'e7a com o segundo elemento, 2, e o compara com o primeiro, 5. Como 2 \'e9 menor que 5, o algoritmo move o 5 para a direita e insere o 2 na posi\'e7\'e3o correta, resultando na lista [2, 5, 9, 1, 5, 6]. Agora, o algoritmo avan\'e7a para o pr\'f3ximo elemento, que \'e9 9. Ele compara 9 com 5 e, como 9 \'e9 maior, n\'e3o h\'e1 troca e o 9 permanece na mesma posi\'e7\'e3o. O processo segue para o 1, que \'e9 comparado com os elementos anteriores. O 1 \'e9 menor que 5 e 2, ent\'e3o o algoritmo move esses elementos para a direita, inserindo o 1 na posi\'e7\'e3o inicial da lista. O resultado intermedi\'e1rio \'e9 [1, 2, 5, 9, 5, 6]. O algoritmo continua com o pr\'f3ximo 5, que \'e9 comparado com 9. Como o 5 \'e9 menor, o 9 \'e9 movido para a direita, e o 5 \'e9 inserido antes do 9. A lista se torna [1, 2, 5, 5, 9, 6]. Por fim, o algoritmo compara o 6 com 9, trocando-os para inserir o 6 na posi\'e7\'e3o correta, resultando na lista final ordenada: [1, 2, 5, 5, 6, 9]. Esse processo continua repetidamente at\'e9 que todos os elementos estejam na posi\'e7\'e3o correta.\par
\par
Em termos de complexidade te\'f3rica, o Insertion Sort tem desempenho vari\'e1vel dependendo da ordena\'e7\'e3o inicial dos dados. No melhor caso, quando a lista j\'e1 est\'e1 ordenada, o algoritmo apenas verifica que n\'e3o h\'e1 necessidade de mover nenhum elemento, resultando em uma complexidade de O(n), onde n \'e9 o n\'famero de elementos da lista. No pior caso, que ocorre quando a lista est\'e1 em ordem inversa, o algoritmo precisa mover cada elemento para a posi\'e7\'e3o correta, realizando uma s\'e9rie de trocas e compara\'e7\'f5es, o que resulta em uma complexidade de O(n\'b2). Portanto, embora o Insertion Sort seja eficiente para listas pequenas ou parcialmente ordenadas, sua complexidade quadr\'e1tica limita seu uso em listas maiores.\par
\par
\par
O Selection Sort \'e9 um algoritmo de ordena\'e7\'e3o que funciona identificando o menor (ou maior, dependendo da implementa\'e7\'e3o) elemento de uma lista e trocando-o com o primeiro elemento n\'e3o ordenado. O processo \'e9 repetido para os pr\'f3ximos elementos, at\'e9 que toda a lista esteja ordenada. A principal caracter\'edstica desse algoritmo \'e9 que, a cada itera\'e7\'e3o, ele seleciona o valor m\'ednimo e coloca-o na posi\'e7\'e3o correta, movendo gradualmente os menores elementos para o in\'edcio da lista.\par
\par
Por exemplo, dada a lista [5, 2, 9, 1, 5, 6], o algoritmo come\'e7a comparando todos os elementos para encontrar o menor valor. O menor n\'famero \'e9 1, ent\'e3o o algoritmo troca 1 com o primeiro elemento, 5, resultando na lista [1, 2, 9, 5, 5, 6]. Em seguida, o algoritmo encontra o menor valor na parte restante da lista, que \'e9 2, e, como ele j\'e1 est\'e1 na posi\'e7\'e3o correta, n\'e3o h\'e1 troca. O algoritmo continua procurando o menor n\'famero na sublista [9, 5, 5, 6], encontra o 5 e troca-o com o 9. O processo continua at\'e9 que todos os elementos sejam colocados em suas posi\'e7\'f5es corretas, resultando na lista final ordenada [1, 2, 5, 5, 6, 9].\par
\par
Em termos de complexidade te\'f3rica, o Selection Sort tem desempenho O(n\'b2) tanto no melhor quanto no pior caso. No melhor caso, mesmo que a lista j\'e1 esteja ordenada, o algoritmo ainda percorre toda a lista em busca do menor elemento, realizando compara\'e7\'f5es desnecess\'e1rias. No pior caso, que ocorre quando a lista est\'e1 em ordem inversa, o algoritmo tamb\'e9m percorre toda a lista a cada itera\'e7\'e3o, trocando elementos para colocar o menor valor na posi\'e7\'e3o correta. Por isso, o Selection Sort n\'e3o \'e9 muito eficiente para listas grandes, embora tenha a vantagem de usar uma quantidade m\'ednima de mem\'f3ria extra, j\'e1 que as trocas s\'e3o feitas no pr\'f3prio local dos elementos.\par
\par
\par
O Merge Sort \'e9 um algoritmo de ordena\'e7\'e3o que se baseia na t\'e9cnica de divis\'e3o e conquista. A t\'e9cnica de divis\'e3o e conquista consiste em dividir um problema grande em subproblemas menores e mais f\'e1ceis de resolver, resolver esses subproblemas e, finalmente, combinar as solu\'e7\'f5es de maneira eficiente. No caso do Merge Sort, o algoritmo divide recursivamente a lista em duas metades, at\'e9 que cada sublista contenha apenas um elemento, e ent\'e3o come\'e7a o processo de combina\'e7\'e3o dessas sublistas de maneira ordenada.\par
\par
Por exemplo, dada a lista [5, 2, 9, 1, 5, 6], o Merge Sort come\'e7a dividindo a lista ao meio, criando duas sublistas: [5, 2, 9] e [1, 5, 6]. Essas sublistas s\'e3o novamente divididas at\'e9 que cada uma contenha apenas um \'fanico elemento: [5], [2], [9] e [1], [5], [6]. A seguir, as sublistas s\'e3o mescladas. Primeiro, as sublistas [5] e [2] s\'e3o mescladas para formar [2, 5], e as sublistas [9] e [5] s\'e3o mescladas para formar [5, 9]. Em seguida, as duas sublistas resultantes, [2, 5] e [5, 9], s\'e3o mescladas para formar [2, 5, 5, 9]. Da mesma forma, as sublistas [1] e [5] s\'e3o mescladas para formar [1, 5], e as sublistas [6] e [1, 5] s\'e3o mescladas para formar [1, 5, 6]. Finalmente, as duas sublistas ordenadas [2, 5, 5, 9] e [1, 5, 6] s\'e3o mescladas para formar a lista final ordenada [1, 2, 5, 5, 6, 9].\par
\par
Em termos de complexidade te\'f3rica, o Merge Sort tem uma performance de O(n log n) tanto no melhor quanto no pior caso. No melhor caso, quando os dados j\'e1 est\'e3o quase ordenados, o algoritmo ainda divide a lista em partes e mescla as sublistas de maneira eficiente. No pior caso, mesmo quando a lista est\'e1 em ordem inversa, o algoritmo ainda mant\'e9m essa efici\'eancia, dividindo as listas de forma balanceada e mesclando-as de maneira ordenada. O desempenho consistente do Merge Sort o torna muito eficiente para grandes volumes de dados, especialmente em cen\'e1rios onde a estabilidade (manter a ordem relativa dos elementos iguais) \'e9 necess\'e1ria. No entanto, uma desvantagem do Merge Sort \'e9 que ele exige espa\'e7o adicional para armazenar as sublistas tempor\'e1rias durante o processo de mesclagem.\par
\par
O Quick Sort \'e9 um algoritmo de ordena\'e7\'e3o eficiente baseado na t\'e9cnica de divis\'e3o e conquista. O funcionamento do Quick Sort envolve a escolha de um elemento chamado piv\'f4 e a parti\'e7\'e3o da lista em duas sublistas: uma contendo elementos menores que o piv\'f4 e outra com elementos maiores. Em seguida, o processo \'e9 recursivamente repetido para essas sublistas, at\'e9 que toda a lista esteja ordenada. O Quick Sort \'e9 altamente eficiente porque, ao dividir a lista em sublistas menores, ele reduz o problema original a partes menores e mais f\'e1ceis de resolver.\par
\par
Por exemplo, dada a lista [5, 2, 9, 1, 5, 6], o algoritmo come\'e7a escolhendo um piv\'f4, como o n\'famero 5. A lista \'e9 ent\'e3o reorganizada de forma que todos os elementos menores que 5 fiquem \'e0 esquerda do piv\'f4 e todos os elementos maiores que 5 fiquem \'e0 direita. Ap\'f3s a parti\'e7\'e3o, a lista fica assim: [2, 1, 5, 5, 9, 6]. Agora, o algoritmo aplica a mesma t\'e9cnica recursivamente \'e0s duas sublistas [2, 1] e [5, 9, 6]. Para a sublista [2, 1], o n\'famero 1 \'e9 escolhido como piv\'f4 e a lista \'e9 reorganizada para [1, 2]. Para a sublista [5, 9, 6], o n\'famero 5 \'e9 escolhido como piv\'f4, e a lista \'e9 reorganizada para [5, 6, 9]. Finalmente, o algoritmo retorna a lista ordenada [1, 2, 5, 5, 6, 9].\par
\par
Em termos de complexidade te\'f3rica, o Quick Sort tem desempenho de O(n log n) no melhor caso, que ocorre quando a escolha do piv\'f4 divide a lista de maneira balanceada, ou seja, cada divis\'e3o resulta em sublistas de tamanho aproximadamente igual. Esse caso ocorre quando o piv\'f4 est\'e1 em uma posi\'e7\'e3o central. No pior caso, que acontece quando o piv\'f4 escolhido \'e9 o menor ou maior elemento da lista, as parti\'e7\'f5es s\'e3o extremamente desbalanceadas, o que leva o algoritmo a se comportar como uma simples busca sequencial. Nesse caso, a complexidade se torna O(n\'b2), o que torna o algoritmo significativamente mais lento. Para mitigar o pior caso, vers\'f5es aprimoradas do Quick Sort, como o Quick Sort aleat\'f3rio, escolhem o piv\'f4 de forma aleat\'f3ria para aumentar a probabilidade de divis\'f5es balanceadas, melhorando a efici\'eancia geral.\par
}
 